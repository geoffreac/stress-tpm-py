import pandas as pd
import numpy as np
import pickle
import os
from scipy.linalg import expm
import matplotlib.pyplot as plt
import seaborn as sns

os.chdir('./stress-tpm-py/')



def load_matrix_npz(file_path):
    with np.load(file_path, allow_pickle=True) as data:
        return [data[key] for key in data]

def save_table_dr(table_dr, file_path):
    with open(file_path, 'wb') as file:
        pickle.dump(table_dr, file)

def load_table_dr(file_path):
    with open(file_path, 'rb') as file:
        return pickle.load(file)

def load_matrix(file_path):
    with open(file_path, 'rb') as file:
        return pickle.load(file)
    
def generate_table_dr(p_cohort, p_duration, OTPM_c_1qa, OTPM_c_1y, levels, seqtime_quarter):
    data = []
    T_end = len(seqtime_quarter)

    for j in range(T_end - 1):
        for delta in range(1, T_end - j):
            for y in range(1, (T_end - j) // delta):
                for r_idx, r in enumerate(levels[:7]):
                    start_date = seqtime_quarter[j]
                    end_date = seqtime_quarter[j + delta * y]
                    
                    # 1-period TPM^t
                    dr_value = np.linalg.matrix_power(p_cohort[delta - 1][j], y)[r_idx, levels.index("D")]
                    data.append([dr_value, "1-period TPM^t", y, "Cohort", r, start_date, end_date, delta])
                    
                    # OTPM_c_1qa^t
                    dr_value = np.linalg.matrix_power(OTPM_c_1qa, delta * y)[r_idx, levels.index("D")]
                    data.append([dr_value, "OTPM_c_1qa^t", y, "Cohort", r, start_date, end_date, delta])

                    # Multi-Year Cohort-ETPM
                    dr_value = p_cohort[delta * y - 1][j][r_idx, levels.index("D")]
                    data.append([dr_value, "Multi-Year Cohort-ETPM", y, "Cohort", r, start_date, end_date, delta])
                    
                    # Average-Cohort-ETPM^t
                    avg_p_cohort = avg_matrix(p_cohort[:T_end-1])
                    dr_value = np.linalg.matrix_power(avg_p_cohort, delta * y)[r_idx, levels.index("D")]
                    data.append([dr_value, "Average-Cohort-ETPM^t", y, "Cohort", r, start_date, end_date, delta])
                    
                    # Multi-Year Duration-ETPM
                    dr_value = p_duration[delta * y - 1][j][r_idx, levels.index("D")]
                    data.append([dr_value, "Multi-Year Duration-ETPM", y, "Duration", r, start_date, end_date, delta])
                    
                    # Average-Duration-ETPM^t
                    avg_p_duration = avg_matrix(p_duration[:T_end-1])
                    dr_value = np.linalg.matrix_power(avg_p_duration, delta * y)[r_idx, levels.index("D")]
                    data.append([dr_value, "Average-Duration-ETPM^t", y, "Duration", r, start_date, end_date, delta])
                    
                    # OTPM_c_1y^t
                    dr_value = np.linalg.matrix_power(OTPM_c_1y, (delta * y) // 4)[r_idx, levels.index("D")]
                    data.append([dr_value, "OTPM_c_1y^t", y, "Cohort", r, start_date, end_date, delta])

    columns = ["DR", "Method", "Index", "Type", "Rating", "Start_Date", "Time_Horizon", "Delta_t"]
    table_dr = pd.DataFrame(data, columns=columns)
    table_dr['Rating'] = pd.Categorical(table_dr['Rating'], categories=levels)
    table_dr['Type'] = pd.Categorical(table_dr['Type'])
    return table_dr


def inertia(df_matrix):
    # Assume "D" is the last row and column
    last_state = df_matrix.index[-1]
    
    # Calculate the sum of diagonal entries, excluding the "D" state
    inertia_value = df_matrix.loc[df_matrix.index != last_state, df_matrix.columns != last_state].values.trace()
    
    return inertia_value

def bias(X):
    upper_mask = np.triu(np.ones(X.shape), k=1).astype(bool)
    lower_mask = np.tril(np.ones(X.shape), k=-1).astype(bool)

    upper_sum = X.where(upper_mask).sum().sum()
    lower_sum = X.where(lower_mask).sum().sum()

    return lower_sum/ upper_sum  if lower_sum != 0 else 0
    

def DR(X):
    if isinstance(X, pd.DataFrame):
        return X.iloc[:-1, -1].sum()
    
    elif isinstance(X, list):
        return np.array([DR(p) for p in X if isinstance(p, pd.DataFrame)])
    
    return 0

def avg_matrix(X):
    return np.mean(np.stack(X), axis=0) if isinstance(X, list) else np.mean(X, axis=2)

def plot_dr_comparison(table_dr, seqtime_quarter):
    temp = table_dr[(table_dr['Index'] == 1) & (table_dr['Delta_t'] == 4) & 
                    (table_dr['Method'].isin(["Multi-Year Cohort-ETPM", "Multi-Year Duration-ETPM"]))]
    
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=temp, x="Start_Date", y="DR", hue="Method", marker="o")
    plt.title("Comparison of DRs from Different Matrix")
    plt.show()

import matplotlib.pyplot as plt
import seaborn as sns


def plot_dr_comparison(table_dr, seqtime_quarter):
    temp = table_dr[(table_dr['Index'] == 1) & (table_dr['Delta_t'] == 4) & 
                    (table_dr['Method'].isin(["Multi-Year Cohort-ETPM", "Multi-Year Duration-ETPM"]))]
    
    plt.figure(figsize=(10, 6))
    sns.lineplot(data=temp, x="Start_Date", y="DR", hue="Method", marker="o")
    plt.title("Comparison of DRs from Different Matrix")
    plt.show()


if __name__ == "__main__":
    # Load necessary matrices
    p_cohort = load_matrix('./data_source/generated_data/p_cohort.pkl')
    # p_duration = load_matrix('./data_source/generated_data/p_duration.pkl')
    # OTPM_c_1qa = load_matrix('./data_source/generated_data/OTPM_c_1qa.pkl')
    # OTPM_c_1y = load_matrix('./data_source/generated_data/OTPM_c_1y.pkl')
    
    # Define the levels (assuming it's predefined)
    levels = ["AAA", "AA", "A", "BBB", "BB", "B", "CCC", "D", "NR"]
    
    # Generate the table_dr
    seqtime_quarter = pd.date_range(start="2011-03-01", end="2019-03-01", freq="Q")
    # table_dr = generate_table_dr(p_cohort, p_duration, OTPM_c_1qa, OTPM_c_1y, levels, seqtime_quarter)
    
    # Save the generated data
    # save_table_dr(table_dr, './generated_data/table_dr.pkl')
    # Initialize list_metrics as a nested dictionary structure
  

    # # Populate list_metrics with calculated values
    # # for i in range(1, T_end):
    # i=4
    # T_end = 31  # Replace with the actual T_end
    # list_metrics = {j: {} for j in range(1, T_end - i)}
    # for j in range(1, T_end - i):
    #     cohort_matrices = p_cohort[i][j]
    #     # duration_matrices = p_duration[i][j:T_end - i]
        
    #     list_metrics[j]['inertia_cohort'] = inertia(cohort_matrices)
    #     # list_metrics[i][j]['inertia_duration'] = inertia(duration_matrices)
    #     list_metrics[j]['bias_cohort'] = bias(cohort_matrices)
    #     # list_metrics[i][j]['bias_duration'] = bias(duration_matrices)
    #     list_metrics[j]['DR_cohort'] = DR(cohort_matrices)
    #     # list_metrics[i][j]['DR_duration'] = DR(duration_matrices)
    #     # list_metrics[j]['avg_cohort'] = avg_matrix(cohort_matrices)
    #     # list_metrics[i][j]['avg_duration'] = avg_matrix(duration_matrices)

    # Set T_end and i values as appropriate
    T_end = 31  # Replace with the actual T_end
    i = 4  # T = 1 year

    # Initialize list_metrics to store lists for each metric
    list_metrics = {
        'inertia_cohort': [],
        'bias_cohort': [],
        'DR_cohort': [],
        # Uncomment and add any other metrics you want to track
        # 'inertia_duration': [],
        # 'bias_duration': [],
        # 'DR_duration': [],
        # 'avg_cohort': [],
        # 'avg_duration': []
    }

    for j in range(1, T_end - i):
        cohort_matrices = p_cohort[i][j]
        # duration_matrices = p_duration[i][j:T_end - i]

        # Append metric values to their respective lists
        list_metrics['inertia_cohort'].append(inertia(cohort_matrices))
        list_metrics['bias_cohort'].append(bias(cohort_matrices))
        list_metrics['DR_cohort'].append(DR(cohort_matrices))

        # Uncomment to add values for additional metrics
        # list_metrics['inertia_duration'].append(inertia(duration_matrices))
        # list_metrics['bias_duration'].append(bias(duration_matrices))
        # list_metrics['DR_duration'].append(DR(duration_matrices))
        # list_metrics['avg_cohort'].append(avg_matrix(cohort_matrices))
        # list_metrics['avg_duration'].append(avg_matrix(duration_matrices))


    # Save list_metrics to a file
    with open("./data_source/generated_data/list_metrics.pkl", "wb") as f:
        pickle.dump(list_metrics, f)

    # Here `seqtime_quarter` should have the same length as the number of entries in each list within list_metrics
    metrics_df = pd.DataFrame({
        'Time': seqtime_quarter[:len(list_metrics['inertia_cohort'])],  # Adjust length if needed
        'Inertia Cohort': list_metrics['inertia_cohort'],
        'Bias Cohort': list_metrics['bias_cohort'],
        'DR Cohort': list_metrics['DR_cohort'],
        # Uncomment if additional metrics are available
        # 'Inertia Duration': list_metrics['inertia_duration'],
        # 'Bias Duration': list_metrics['bias_duration'],
        # 'DR Duration': list_metrics['DR_duration']
    })

    # Initialize the plot with subplots for each metric
    fig, axes = plt.subplots(3, 1, figsize=(12, 15), sharex=True)
    sns.set_style("whitegrid")

    # Plot each metric on a separate subplot
    sns.lineplot(data=metrics_df, x='Time', y='Inertia Cohort', marker="o", ax=axes[0], color="b")
    axes[0].set_title("Inertia Cohort Over Time")
    axes[0].set_ylabel("Inertia Value")

    sns.lineplot(data=metrics_df, x='Time', y='Bias Cohort', marker="o", ax=axes[1], color="g")
    axes[1].set_title("Bias Cohort Over Time")
    axes[1].set_ylabel("Bias Value")

    sns.lineplot(data=metrics_df, x='Time', y='DR Cohort', marker="o", ax=axes[2], color="r")
    axes[2].set_title("Default Rate (DR) Cohort Over Time")
    axes[2].set_ylabel("DR Value")

    # Set x-axis label only on the bottom plot
    axes[2].set_xlabel("Time (Quarters)")

    # Rotating x-tick labels for better readability
    for ax in axes:
        plt.setp(ax.get_xticklabels(), rotation=45)

    # Tight layout to adjust spacing
    plt.tight_layout()

    # Display the plot
    plt.show()

    print('test')
